# Main entrypoint of the workflow.
# Please follow the best practices:
# https://snakemake.readthedocs.io/en/stable/snakefiles/best_practices.html,
# in particular regarding the standardized folder structure mentioned there.


configfile: "config/config.yaml"

scattergather:
    split_candidates=10,
    split_reads=10

read_type = config["read_type"]
chromosome_conf = config["sample"]
accession = config["accession"]


aligned_bam_reads = (
    "resources/aligned-reads-pacbio.bam"
    if read_type == "PacBio"
    else "resources/aligned-reads-illumina.bam"
)

aligned_bam_reads_index = (
    "resources/aligned-reads-pacbio-sorted.bam.bai"
    if read_type == "PacBio"
    else "resources/aligned-reads-illumina-sorted.bam.bai"
)

aligned_sam_reads = (
    "resources/aligned-reads-pacbio.sam"
    if read_type == "PacBio"
    else "resources/aligned-reads-illumina.sam"
)

aligned_bam_reads_sorted = (
    "resources/aligned-reads-pacbio-sorted.bam"
    if read_type == "PacBio"
    else "resources/aligned-reads-illumina-sorted.bam"
)

aligned_sam_reads_sorted = (
    "resources/aligned-reads-pacbio-sorted.sam"
    if read_type == "PacBio"
    else "resources/aligned-reads-illumina-sorted.sam"
)


rule all:
    input:
        dv="results/scatter_plot_dv.png",
        tv="results/scatter_plot_tv.png",
        td="results/scatter_plot_td.png"


rule get_genome:
    output:
        "resources/genome.fasta",
    params:
        species=chromosome_conf["species"],
        datatype=chromosome_conf["datatype"],
        build=chromosome_conf["build"],
        release=chromosome_conf["release"],
    log:
        "logs/get_chr21.log",
    cache: "omit-software"  # save space and time with between workflow caching (see docs)
    wrapper:
        "v2.3.2/bio/reference/ensembl-sequence"


rule get_chromosome:
    output:
        "resources/chromosome.fasta",
    params:
        species=chromosome_conf["species"],
        datatype=chromosome_conf["datatype"],
        build=chromosome_conf["build"],
        release=chromosome_conf["release"],
        chromosome=chromosome_conf["chromosome"],
    log:
        "logs/get_chromosome.log",
    cache: "omit-software"  # save space and time with between workflow caching (see docs)
    wrapper:
        "v2.3.2/bio/reference/ensembl-sequence"


rule filter_genome:
    input:
        "resources/genome.fasta",
    output:
        "resources/chr21.fasta",
    log:
        "logs/filter_genome.log",
    conda:
        "envs/samtools.yaml"
    params:
        pipeline_path=config["pipeline_path"],
    threads: 10
    shell:
        """ 
        samtools faidx {input} 21 > {output}
        """


rule chr21_index:
    input:
        "resources/chr21.fasta",
    output:
        "resources/chr21.fasta.fai",
    log:
        "logs/chr21_index.log",
    conda:
        "envs/samtools.yaml"
    params:
        pipeline_path=config["pipeline_path"],
    shell:
        """ 
        samtools faidx {params.pipeline_path}{input}
        """


rule find_candidates:
    input:
        "resources/chr21.fasta",
    output:
        "resources/candidates.bcf",
    log:
        "logs/find_candidates.log",
    conda:
        "envs/varlociraptor.yaml"
    params:
        varlo_path=config["varlo_path"],
        pipeline_path=config["pipeline_path"],
    shell:
        """ 
        cd {params.varlo_path}
        cargo run -- methylation-candidates {params.pipeline_path}{input} {params.pipeline_path}{output}
        """



# Unused
rule candidates_to_vcf:
    input:
        "resources/candidates.bcf",
    output:
        "resources/candidates.vcf",
    conda:
        "envs/samtools.yaml"
    log:
        "logs/convert_to_vcf.log",
    threads: 10
    shell:
        """
        bcftools view --threads {threads} {input} > {output}
        """

rule split_candidates:
    input:
        "resources/candidates.bcf",
    output:
        temp(scatter.split_candidates("resources/candidates_{scatteritem}.bcf"))
    log:
        "logs/split_candidates.log",
    conda:
        "envs/rbt.yaml"
    shell:
        "rbt vcf-split {input} {output}"


rule get_fastq_pe:
    output:
        # the wildcard name must be accession, pointing to an SRA number
        "resources/{accession}_1.fastq",
        "resources/{accession}_2.fastq",
    log:
        "logs/pe/{accession}.log"
    params:
        extra="--skip-technical"
    threads: 20  # defaults to 6
    conda:
        "envs/fastq-wrapper.yaml"
    wrapper:
        "v2.6.0/bio/sra-tools/fasterq-dump"


rule split_reads1:
    input:
       "resources/{accession}_1.fastq",
    output:
        temp(scatter.split_reads("resources/example_new/read1_{scatteritem}.fastq")),
    log:
        "logs/split_reads1.log",
    conda:
        "envs/rbt.yaml"
    shell:
        """
        rbt fastq-split {output} < {input}
        """

rule split_reads2:
    input:
        "resources/{accession}_2.fastq",
    output:
        temp(scatter.split_reads("resources/example_new/read2_{scatteritem}.fastq")),
    log:
        "logs/split_reads2.log",
    conda:
        "envs/rbt.yaml"
    shell:
        """
        rbt fastq-split {output} < {input}
        """



rule align_reads:
    input:
        fasta="resources/genome.fasta",
        reads1="resources/example_new/read1_{scatteritem}.fastq",
        reads2="resources/example_new/read2_{scatteritem}.fastq",
    output:
        temp("resources/example_new/aligned-reads-{scatteritem}.bam")
        # aligned_bam_reads
    conda:
        "envs/bwa-meth.yaml"
    log:
        "logs/align_reads_{scatteritem}.log",
        # "logs/align_reads.log",
    threads: 20
    shell:
        """
        bwameth.py index-mem2 {input.fasta}
        bwameth.py --threads {threads} --reference {input.fasta} {input.reads1} {input.reads2}  | samtools view -S -b - > {output}
        """

rule gather_alignment:
    input:
        gather.split_reads("resources/example_new/aligned-reads-{scatteritem}.bam")
    output:
        aligned_bam_reads
    conda:
        "envs/samtools.yaml"
    shell:
        "samtools merge  {output} {input}"



# Unused
rule aligned_reads_sorted_sam:
    input:
        aligned_bam_reads,
    output:
        sam_reads=aligned_sam_reads,
        sam_sorted=aligned_sam_reads_sorted,
    log:
        "logs/aligned_reads_sorted_sam.log",
    conda:
        "envs/samtools.yaml"
    params:
        pipeline_path=config["pipeline_path"],
    threads: 10
    shell:
        """ 
        samtools view -@ {threads} -bS {params.pipeline_path}{input} > {params.pipeline_path}/{output.sam_reads}    
        samtools sort -@ {threads} {output.sam_reads} -o {output.sam_sorted}    
        """

rule sort_aligned_reads:
    input:
        aligned_bam_reads,
    output:
        aligned_bam_reads_sorted,
    log:
        "logs/sort_aligned_reads.log",
    conda:
        "envs/samtools.yaml"
    params:
        pipeline_path=config["pipeline_path"],
    threads: 10
    shell:
        """
        samtools sort -@ {threads}  {input} -o {output}    
        """

rule aligned_reads_index:
    input:
        aligned_bam_reads_sorted,
    output:
        aligned_bam_reads_index,
    log:
        "logs/aligned_reads_to_bam.log",
    conda:
        "envs/samtools.yaml"
    params:
        pipeline_path=config["pipeline_path"],
    threads: 10
    shell:
        """
        samtools index -@ {threads} {params.pipeline_path}/{input}
        """

rule filter_aligned_reads:
    input:
        bam=aligned_bam_reads_sorted,
        index=aligned_bam_reads_index,
    output:
        "resources/alignment_focused.bam"
    log:
        "logs/chr21_index.log",
    conda:
        "envs/samtools.yaml"
    params:
        pipeline_path=config["pipeline_path"],
    threads: 10
    shell:
        """ 
        samtools view -b -o {output} {input.bam} chr21
        """

rule aligned_reads_filtered_index:
    input:
        "resources/alignment_focused.bam"
    output:
        "resources/alignment_focused.bam.bai"
    log:
        "logs/aligned_reads_to_bam.log",
    conda:
        "envs/samtools.yaml"
    params:
        pipeline_path=config["pipeline_path"],
    threads: 10
    shell:
        """
        samtools index -@ {threads} {params.pipeline_path}/{input}
        """

rule methylDackel:
    input:
        chr21="resources/chr21.fasta",
        alignment="resources/alignment_focused.bam",
        alignment_index="resources/alignment_focused.bam.bai"
    output:
        "results/alignments_CpG.bedGraph",
    conda:
        "envs/methylDackel.yaml"
    log:
        "logs/methylDackel.log",
    params:
        pipeline_path=config["pipeline_path"],
    shell:
        """
        MethylDackel extract {input.chr21} {input.alignment} -o {params.pipeline_path}/results/alignments --mergeContext
        """

rule compute_meth_observations:
    input:
        chr21="resources/chr21.fasta",
        chr21_index="resources/chr21.fasta.fai",
        alignments=aligned_bam_reads_sorted,
        alignments_index=aligned_bam_reads_index,
        candidates="resources/candidates_{scatteritem}.bcf"
        # candidates="resources/candidates.bcf",
    output:
        temp("results/normal_{scatteritem}.bcf"),
        # "results/normal.bcf",
    log:
        "logs/compute_{scatteritem}.log",
    conda:
        "envs/varlociraptor.yaml"
    params:
        varlo_path=config["varlo_path"],
        pipeline_path=config["pipeline_path"],
        read_type=config["read_type"],
    shell:
        """ 
        cd {params.varlo_path}
        cargo run --release -- preprocess variants {params.pipeline_path}{input.chr21} --candidates {params.pipeline_path}{input.candidates} --bam {params.pipeline_path}{input.alignments} --read-type {params.read_type} > {params.pipeline_path}{output}
        """

# Unused
rule observations_to_vcf:
    input:
        "results/normal_{scatteritem}.bcf",
        # "results/normal.bcf",
    output:
        temp("results/normal_{scatteritem}.vcf"),
        # "results/normal.vcf",
    conda:
        "envs/samtools.yaml"
    log:
        "logs/convert_to_vcf_{scatteritem}.log",
    threads: 10
    shell:
        """
        bcftools view --threads {threads} {input} > {output}
        """


rule call_methylation:
    input:
        preprocess_obs="results/normal_{scatteritem}.bcf",
        # preprocess_obs="results/normal.bcf",
        scenario="resources/scenario.yaml",
    output:
        temp("results/calls_{scatteritem}.bcf"),
        # "results/calls.bcf",
    log:
        "logs/compute_{scatteritem}.log",
    conda:
        "envs/varlociraptor.yaml"
    params:
        varlo_path=config["varlo_path"],
        pipeline_path=config["pipeline_path"],
        read_type=config["read_type"],
    shell:
        """ 
        cd {params.varlo_path}
        cargo run --release -- call variants --omit-strand-bias generic --scenario {params.pipeline_path}{input.scenario} --obs normal={params.pipeline_path}{input.preprocess_obs} > {params.pipeline_path}/{output}
        """


rule calls_to_vcf:
    input:
        "results/calls_{scatteritem}.bcf",
        # "results/calls.bcf",
    output:
        temp("results/calls_{scatteritem}.vcf"),
        # "results/calls.vcf",
    conda:
        "envs/samtools.yaml"
    log:
        "logs/convert_to_vcf_{scatteritem}.log",
    threads: 10
    shell:
        """
        bcftools --threads {threads} view {input} -o {output}
        """



rule gather_calls:
    input:
        gather.split_candidates("results/calls_{scatteritem}.vcf")
    output:
        "results/calls.vcf"
    shell:
        "cat {input} > {output}"



rule download_bedGraphs:
    output:
        "resources/HG002/{bedGraph}.bedGraph.gz",
    log:
        "logs/download_bedGraphs{bedGraph}.log",
    params:
        pipeline_path=config["pipeline_path"],
        bedGraphs = config["bedGraphs_HG002"]
    script:
        "scripts/get_bedGraph_data.py"

ruleorder: filter_bedGraphs > process_data

rule process_data:
    input:
        "resources/HG002/{bedGraph}.bedGraph.gz"
    output:
        "resources/HG002/{bedGraph}.bedGraph"
    log:
        "logs/process_data{bedGraph}.log",
    shell:
        "gunzip -c {input} > {output}"

rule filter_bedGraphs:
    input:
        "resources/HG002/{bedGraph}.bedGraph"
    output:
        "resources/HG002/{bedGraph}_filtered.bedGraph"
    log:
        "logs/filter_bedGraphs{bedGraph}.log",
    shell:
        """
        awk '$1 == "chr21" {{print}}' {input} > {output}
        """

rule compute_avg_bedGraph:
    input:
        # expand("resources/HG002/bedGraph/{bed}.bedGraph", bed=bedGraphs),
        expand("resources/HG002/{bedGraph}_filtered.bedGraph", bedGraph=config["bedGraphs_HG002"])

    output:
        "resources/bed_avg.bedGraph",
    log:
        "logs/compute_avg_bedGraph.log",
    params:
        chromosome=chromosome_conf["chromosome"],
    script:
        "scripts/compute_avg_bedGraph.py"


rule plot_results:
    input:
        bedGraph="results/alignments_CpG.bedGraph",
        calls="results/calls.vcf",
        true_meth="resources/bed_avg.bedGraph"
    output:
        dv="results/scatter_plot_dv.png",
        tv="results/scatter_plot_tv.png",
        td="results/scatter_plot_td.png"
    conda:
        "envs/plot.yaml"
    log:
        "logs/plot_results.log",
    script:
        "scripts/scatter_plot.py"
