# Main entrypoint of the workflow.
# Please follow the best practices:
# https://snakemake.readthedocs.io/en/stable/snakefiles/best_practices.html,
# in particular regarding the standardized folder structure mentioned there.

from pathlib import Path


configfile: "config/config.yaml"


scattergather:
    split_candidates=20,


chromosome_by_platform = config["platforms"]
chromosomes = set(chromosome for chromosome in config["platforms"].values())
chr_chromosome = set("chr" + str(chromosome) for chromosome in chromosomes)
platform = config["data"]
candidate = config["candidate"]


report: "report/workflow.rst"


include: "rules/common.smk"
include: "rules/bismark.smk"
include: "rules/bisSnp.smk"
include: "rules/bsmap.smk"
include: "rules/get_alignments.smk"
include: "rules/get_data.smk"
include: "rules/get_reference_begraph.smk"
include: "rules/human_readable.smk"
include: "rules/methylDackel.smk"
include: "rules/modkit.smk"
include: "rules/testcase.smk"
# include: "rules/fake_data.smk"
include: "rules/pbCpgTools.smk"


rule all:
    input:
        compute_results(),


rule find_candidates:
    input:
        expand(
            "resources/chromosome_{chrom}.fasta",
            chrom=chr_chromosome,
        ),
    output:
        "resources/{chromosome}/candidates.bcf",
    log:
        "logs/{chromosome}/find_candidates.log",
    conda:
        "envs/varlociraptor.yaml"
    params:
        varlo_path=config["varlo_path"],
        pipeline_path=config["pipeline_path"],
    shell:
        """ 
        cd {params.varlo_path}
        cargo run -- methylation-candidates {params.pipeline_path}{input} {params.pipeline_path}{output}
        """


rule split_candidates:
    input:
        expand(
            "resources/{chrom}/candidates.bcf",
            chrom=[chrom for chrom in chromosomes],
        ),
    output:
        scatter.split_candidates("resources/{{chrom}}/candidates_{scatteritem}.bcf"),
    log:
        "logs/{chrom}split_candidates.log",
    conda:
        "envs/rbt.yaml"
    shell:
        "rbt vcf-split {input} {output}"


rule compute_meth_observations:
    input:
        chromosome=lambda wildcards: expand(
            "resources/chromosome_{chrom}.fasta",
            chrom=chromosome_by_platform[wildcards.platform],
        ),
        genome_index=lambda wildcards: expand(
            "resources/chromosome_{chrom}.fasta.fai",
            chrom=chromosome_by_platform[wildcards.platform],
        ),
        alignments="resources/{platform}/{protocol}/candidate_specific/alignment_valid_{scatteritem}.bam",
        alignment_index="resources/{platform}/{protocol}/candidate_specific/alignment_valid_{scatteritem}.bam.bai",
        candidates=lambda wildcards: expand(
            "resources/{chrom}/candidates_{{scatteritem}}.bcf",
            chrom=chromosome_by_platform[wildcards.platform],
        ),
    output:
        "results/{platform}/{protocol}/normal_{scatteritem}.bcf",
    log:
        "logs/compute_meth_observations_{platform}_{protocol}_{scatteritem}.log",
    conda:
        "envs/varlociraptor.yaml"
    params:
        varlo_path=config["varlo_path"],
        pipeline_path=config["pipeline_path"],
    shell:
        """ 
        cd {params.varlo_path}
        if [[ "{wildcards.platform}" == "Illumina_pe" || "{wildcards.platform}" == "Illumina_se" ]]; then
            PLATFORM="Illumina"
        else
            PLATFORM="{wildcards.platform}"
        fi
        echo $PLATFORM
        cargo run --release -- preprocess variants {params.pipeline_path}{input.chromosome} --candidates {params.pipeline_path}{input.candidates} --bam {params.pipeline_path}{input.alignments} --read-type $PLATFORM --max-depth 5000 > {params.pipeline_path}{output}
        """


rule call_methylation:
    input:
        preprocess_obs="results/{platform}/{protocol}/normal_{scatteritem}.bcf",
        scenario="resources/scenario.yaml",
    output:
        "results/{platform}/{protocol}/calls_{scatteritem}.bcf",
    log:
        "logs/call_methylation_{platform}_{protocol}_{scatteritem}.log",
    conda:
        "envs/varlociraptor.yaml"
    params:
        varlo_path=config["varlo_path"],
        pipeline_path=config["pipeline_path"],
    shell:
        """ 
        cd {params.varlo_path}
        cargo run --release -- call variants --omit-read-position-bias generic --scenario {params.pipeline_path}{input.scenario} --obs normal={params.pipeline_path}{input.preprocess_obs} > {params.pipeline_path}{output}
        """


# TODO: Reactivate, right now it deletes too much data
rule filter_calls:
    input:
        "results/{platform}/{protocol}/calls_{scatteritem}.bcf",
    output:
        "results/{platform}/{protocol}/calls_{scatteritem}.filtered.bcf",
    log:
        "logs/filter_calls_{platform}_{protocol}_{scatteritem}.log",
    conda:
        "envs/varlociraptor.yaml"
    params:
        varlo_path=config["varlo_path"],
        pipeline_path=config["pipeline_path"],
        event="PRESENT",
    shell:
        """
        cd {params.varlo_path}
        cargo run --release -- filter-calls control-fdr --mode local-smart {params.pipeline_path}{input} --events {params.event} --fdr 0.005 > {params.pipeline_path}{output}
        """


rule calls_to_vcf:
    input:
        "results/{platform}/{protocol}/calls_{scatteritem}.bcf",
    output:
        "results/{platform}/{protocol}/calls_{scatteritem}.vcf",
    conda:
        "envs/samtools.yaml"
    log:
        "logs/convert_to_vcf_{platform}_{protocol}_{scatteritem}.log",
    threads: 10
    shell:
        """
        bcftools view --threads {threads} {input} -o {output}
        """


rule gather_calls:
    input:
        gather.split_candidates(
            "results/{{platform}}/{{protocol}}/calls_{scatteritem}.vcf"
        ),
    output:
        "results/{platform}/{protocol}/calls.vcf",
    log:
        "logs/gather_calls_{platform}_{protocol}.log",
    conda:
        "envs/cat.yaml"
    shell:
        "cat {input} > {output}"


rule plot_results:
    input:
        tool="results/{platform}/{protocol}/calls.vcf",
        true_meth=lambda wildcards: expand(
            "resources/bed_avg_{chrom}.bedGraph",
            chrom=chromosome_by_platform[wildcards.platform],
        ),
    output:
        plot = report(
            expand(
                "results/{{platform}}/{{protocol}}/plots/varlo/scatter_{cov_bins}.{plot_type}",
                cov_bins=[i for i in range(0, config["cov_bins"])],
                plot_type=config["plot_type"],
            ),
            # caption="../report/metilene_plots.rst",
            category=lambda wildcards: wildcards.platform,
            subcategory="Varlo plots",
            labels=lambda wildcards: {
                "scatter_plot coverage": wildcards.cov_bins - wildcards.cov_bins + confi["cov_bin_size"],
            },
        ),
        tool_dist = report(
            expand(
                "results/{{platform}}/{{protocol}}/plots/varlo/dist_{cov_bins}.{plot_type}",
                cov_bins=[i for i in range(0, config["cov_bins"])],
                plot_type=config["plot_type"],
            ),
            category=lambda wildcards: wildcards.platform,
            subcategory="Varlo plots",
        ),
        precall=expand("results/{{platform}}/{{protocol}}/plots/varlo/precall_{cov_bins}.csv",
            cov_bins=[i for i in range(0, config["cov_bins"])],
        ),

        # bias_pos="results/{platform}/{protocol}/bias.txt",
    conda:
        "envs/plot.yaml"
    log:
        "logs/plot_results_{platform}_{protocol}.log",
    params:
        plot_type=config["plot_type"],
        cov_bins=config["cov_bins"],
        cov_bin_size=config["cov_bin_size"],
    script:
        "scripts/scatter_plot.py"


rule plot_dist_comparision:
    input:
        tool="results/{platform}/{protocol}/calls.vcf",
        # true_meth=lambda wildcards: expand(
        #     "resources/bed_avg_{chrom}.bedGraph",
        #     chrom=chromosome_by_platform[wildcards.platform],
        # ),
        true_meth=lambda wildcards: expand(
            "resources/bed_avg_{chrom}.bedGraph",
            chrom=chromosome_by_platform[wildcards.platform],
        ),
        ref_tool="results/ref_tools/{method}/{protocol}/{method}.bed",
        # ref_tool="results/ref_tools/methylDackel/TruSeq_HG002_LAB01_REP01/methylDackel.bed",
    output:
        plot=report(
            expand(
            "results/{{platform}}/{{protocol}}/plots/dist_comp_{{method}}.{plot_type}",
            plot_type=config["plot_type"],
        ),
            category=lambda wildcards: wildcards.platform,
            subcategory="Comparisions",
        ),
        scatter_plot=report(expand(
            "results/{{platform}}/{{protocol}}/plots/scatter_comp_{{method}}.{plot_type}",
            plot_type=config["plot_type"],
        ),
            category=lambda wildcards: wildcards.platform,
            subcategory="Comparisions",
        ),
        distances="results/{platform}/{protocol}/debug/distances_{method}.txt",
    conda:
        "envs/plot.yaml"
    log:
        "logs/plot_results_debug_{platform}_{protocol}_{method}.log",
    params:
        plot_type=config["plot_type"],
        cov_bins=config["cov_bins"],
    script:
        "scripts/plot_distances_together.py"


rule plot_ref_results:
    input:
        tool="results/ref_tools/{method}/{protocol}/{method}.bed",
        true_meth=lambda wildcards: expand(
            "resources/bed_avg_{chrom}.bedGraph",
            chrom=chromosome_by_platform[wildcards.platform],
        ),
    output:
        plot=report(
            expand(
            "results/{{platform}}/{{protocol}}/plots/{{method}}/scatter_{cov_bin}.{plot_type}",
            cov_bin=[i for i in range(0, config["cov_bins"])],
            plot_type=config["plot_type"],
        ),
            category=lambda wildcards: wildcards.platform,
            subcategory="Ref_method plots",
        ),
        tool_dist=report(
            expand(
            "results/{{platform}}/{{protocol}}/plots/{{method}}/dist_{cov_bin}.{plot_type}",
            cov_bin=[i for i in range(0, config["cov_bins"])],
            plot_type=config["plot_type"],
            ),
            category=lambda wildcards: wildcards.platform,
            subcategory="Ref_method plots",
        ),
        precall=expand("results/{{platform}}/{{protocol}}/plots/{{method}}/precall_{cov_bins}.csv",
            cov_bins=[i for i in range(0, config["cov_bins"])],
        ),

    conda:
        "envs/plot.yaml"
    params:
        plot_type=config["plot_type"],
        cov_bins=config["cov_bins"],
        cov_bin_size=config["cov_bin_size"],
    log:
        "logs/plot_ref_results_{platform}_{protocol}_{method}.log",
    script:
        "scripts/scatter_plot.py"


rule plot_precision_recall:
    input:
        get_precision_recall_csvs
        # "results/{platform}/{protocol}/plots/varlo/precall_{cov_bin}.csv",
    output:
        report(
            expand(
            "results/{{platform}}/{{protocol}}/plots/precall_{{cov_bin}}.{{plot_type}}",
            ),
            category=lambda wildcards: wildcards.platform,
            subcategory="Comparisions",
        ),

    conda:
        "envs/plot.yaml"
    log:
        # "logs/plot_precision_recall_{platform}_{protocol}_{plot_type}.log",
    params:
        plot_type=config["plot_type"],
    script:
        "scripts/precision_recall.py"


rule debug_distances:
    input:
        tool="results/{platform}/{protocol}/calls.vcf",
        distances="results/{platform}/{protocol}/debug/distances_{method}.txt",
        ref_tool="results/ref_tools/{method}/{protocol}/{method}.bed",
        true_meth=lambda wildcards: expand(
            "resources/bed_avg_{chrom}.bedGraph",
            chrom=chromosome_by_platform[wildcards.platform],
        ),
    output:
        distances="results/{platform}/{protocol}/debug/distances_origin_{method}.txt",
    conda:
        "envs/plot.yaml"
    log:
        "logs/debug_distances_{platform}_{protocol}_{method}.log",
    script:
        "scripts/debug_distances.py"
